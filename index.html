<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>qr2table</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Instrument+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0c0c0f;
    --surface: #16161a;
    --surface-2: #1e1e24;
    --border: #2a2a32;
    --text: #e8e6e3;
    --text-dim: #8a8890;
    --accent: #4af;
    --accent-glow: #4af3;
    --success: #4aea8b;
  }

  body {
    font-family: 'Instrument Sans', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 2rem;
    line-height: 1.5;
  }

  .app {
    max-width: 960px;
    margin: 0 auto;
  }

  header {
    margin-bottom: 3rem;
  }

  header h1 {
    font-family: 'DM Mono', monospace;
    font-size: 1.6rem;
    font-weight: 500;
    letter-spacing: -0.02em;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  header h1 .tag {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    background: var(--accent);
    color: var(--bg);
    padding: 0.2em 0.6em;
    border-radius: 3px;
    font-weight: 600;
    font-family: 'Instrument Sans', sans-serif;
  }

  header p {
    color: var(--text-dim);
    margin-top: 0.5rem;
    font-size: 0.9rem;
  }

  .layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    align-items: start;
  }

  @media (max-width: 700px) {
    .layout { grid-template-columns: 1fr; }
  }

  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
  }

  .panel-title {
    font-family: 'DM Mono', monospace;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-dim);
    margin-bottom: 1.25rem;
  }

  .field { margin-bottom: 1.25rem; }

  .field:last-child { margin-bottom: 0; }

  label {
    display: block;
    font-size: 0.8rem;
    font-weight: 600;
    margin-bottom: 0.4rem;
    color: var(--text-dim);
  }

  input[type="text"], textarea {
    width: 100%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.7rem 0.9rem;
    color: var(--text);
    font-family: 'DM Mono', monospace;
    font-size: 0.85rem;
    outline: none;
    transition: border-color 0.2s;
    resize: vertical;
  }

  input[type="text"]:focus, textarea:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
  }

  textarea { min-height: 80px; }

  .row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  .row-3 {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 1rem;
  }

  .color-input-wrap {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.35rem 0.7rem;
  }

  input[type="color"] {
    -webkit-appearance: none;
    appearance: none;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    cursor: pointer;
    background: none;
    padding: 0;
  }

  input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
  input[type="color"]::-webkit-color-swatch { border: 1px solid #444; border-radius: 5px; }

  .color-hex {
    font-family: 'DM Mono', monospace;
    font-size: 0.78rem;
    color: var(--text-dim);
  }

  input[type="range"] {
    width: 100%;
    accent-color: var(--accent);
    margin-top: 0.3rem;
  }

  .range-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .range-val {
    font-family: 'DM Mono', monospace;
    font-size: 0.8rem;
    color: var(--accent);
    min-width: 3ch;
    text-align: right;
  }

  select {
    width: 100%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.65rem 0.9rem;
    color: var(--text);
    font-family: 'Instrument Sans', sans-serif;
    font-size: 0.85rem;
    outline: none;
    cursor: pointer;
  }

  select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
  }

  /* Preview panel */
  .preview-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    min-height: 300px;
    justify-content: center;
  }

  .qr-container {
    background: #fff;
    padding: 12px;
    border-radius: 8px;
    display: inline-block;
    box-shadow: 0 8px 32px #0004;
  }

  .qr-container table {
    border-collapse: collapse;
    border-spacing: 0;
  }

  .placeholder-msg {
    color: var(--text-dim);
    font-size: 0.85rem;
    text-align: center;
    padding: 3rem 1rem;
  }

  .placeholder-msg .icon {
    font-size: 2.5rem;
    margin-bottom: 0.75rem;
    opacity: 0.4;
  }

  .stats {
    font-family: 'DM Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
    text-align: center;
    line-height: 1.7;
  }

  .stats span { color: var(--accent); }

  .btn-row {
    display: flex;
    gap: 0.75rem;
    margin-top: 1.25rem;
    flex-wrap: wrap;
  }

  button {
    font-family: 'Instrument Sans', sans-serif;
    font-weight: 600;
    font-size: 0.82rem;
    border: none;
    border-radius: 8px;
    padding: 0.65rem 1.2rem;
    cursor: pointer;
    transition: all 0.15s;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  .btn-primary {
    background: var(--accent);
    color: var(--bg);
  }

  .btn-primary:hover {
    filter: brightness(1.15);
    transform: translateY(-1px);
  }

  .btn-secondary {
    background: var(--surface-2);
    color: var(--text);
    border: 1px solid var(--border);
  }

  .btn-secondary:hover {
    border-color: var(--text-dim);
  }

  .btn-success {
    background: var(--success);
    color: var(--bg);
  }

  .toast {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: var(--success);
    color: var(--bg);
    padding: 0.7rem 1.4rem;
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.85rem;
    pointer-events: none;
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index: 100;
  }

  .toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  .info-box {
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1.5rem;
    font-size: 0.78rem;
    color: var(--text-dim);
    line-height: 1.6;
  }

  .info-box strong {
    color: var(--text);
  }

  .checkbox-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }

  .checkbox-row input[type="checkbox"] {
    accent-color: var(--accent);
    width: 16px;
    height: 16px;
  }

  .checkbox-row label {
    margin: 0;
    font-size: 0.82rem;
    cursor: pointer;
  }
</style>
</head>
<body>

<div class="app">
  <header>
    <h1>qr2table <span class="tag">Email-safe</span></h1>
    <p>Generate QR codes as pure HTML tables ‚Äî no images needed, works in every email client.</p>
  </header>

  <div class="layout">
    <!-- Controls -->
    <div>
      <div class="panel">
        <div class="panel-title">Content</div>
        <div class="field">
          <label for="qr-input">Text or URL</label>
          <textarea id="qr-input" placeholder="https://example.com" spellcheck="false">https://example.com</textarea>
        </div>
        <div class="field">
          <label>Error correction</label>
          <select id="ec-level">
            <option value="L">Low (7%) ‚Äî smaller QR</option>
            <option value="M" selected>Medium (15%) ‚Äî recommended</option>
            <option value="Q">Quartile (25%)</option>
            <option value="H">High (30%) ‚Äî most resilient</option>
          </select>
        </div>
      </div>

      <div class="panel" style="margin-top: 1rem;">
        <div class="panel-title">Appearance</div>
        <div class="row">
          <div class="field">
            <label>Foreground</label>
            <div class="color-input-wrap">
              <input type="color" id="fg-color" value="#000000">
              <span class="color-hex" id="fg-hex">#000000</span>
            </div>
          </div>
          <div class="field">
            <label>Background</label>
            <div class="color-input-wrap">
              <input type="color" id="bg-color" value="#ffffff">
              <span class="color-hex" id="bg-hex">#ffffff</span>
            </div>
          </div>
        </div>
        <div class="field">
          <div class="range-row">
            <label for="cell-size">Cell size</label>
            <span class="range-val" id="cell-size-val">4px</span>
          </div>
          <input type="range" id="cell-size" min="1" max="12" value="4">
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="quiet-zone" checked>
          <label for="quiet-zone">Include quiet zone (recommended for scanning)</label>
        </div>
      </div>

      <div class="panel" style="margin-top: 1rem;">
        <div class="panel-title" style="display:flex;align-items:center;gap:0.5rem;">
          Lossy compression
          <span style="font-size:0.6rem;background:#f84;color:var(--bg);padding:0.15em 0.5em;border-radius:3px;letter-spacing:0.08em;font-family:'Instrument Sans',sans-serif;font-weight:600;">EXPERIMENTAL</span>
        </div>
        <div class="checkbox-row" style="margin-top:0;">
          <input type="checkbox" id="lossy-enabled">
          <label for="lossy-enabled">Enable lossy module flipping</label>
        </div>
        <div id="lossy-controls" style="display:none;margin-top:1rem;">
          <div class="field">
            <div class="range-row">
              <label for="lossy-budget">Aggressiveness</label>
              <span class="range-val" id="lossy-budget-val">20%</span>
            </div>
            <input type="range" id="lossy-budget" min="5" max="100" value="20">
          </div>
          <div style="font-size:0.75rem;color:var(--text-dim);line-height:1.5;margin-top:0.5rem;">
            Flips isolated data modules to create larger mergeable regions. Finder patterns, alignment patterns, timing, format &amp; version info are fully protected. Higher EC levels give more headroom. Always verify with a scanner.
          </div>
          <div id="lossy-stats" style="font-family:'DM Mono',monospace;font-size:0.72rem;color:var(--text-dim);margin-top:0.75rem;display:none;"></div>
        </div>
      </div>

      <div class="info-box">
        <strong>Why tables?</strong> Unlike images, HTML tables render everywhere ‚Äî Outlook, Gmail, Apple Mail, Yahoo ‚Äî with zero blocking or broken icons. The QR is built from tiny <code>&lt;td&gt;</code> cells with inline styles, so it survives even the most aggressive email sanitizers.
      </div>
    </div>

    <!-- Preview -->
    <div>
      <div class="panel">
        <div class="panel-title">Preview</div>
        <div class="preview-area" id="preview-area">
          <div class="placeholder-msg">
            <div class="icon">‚è≥</div>
            Generating‚Ä¶
          </div>
        </div>
        <div class="stats" id="stats" style="display:none;"></div>
        <div class="btn-row">
          <button class="btn-primary" id="copy-rich-btn" onclick="copyRich()">üìã Copy for email</button>
          <button class="btn-secondary" id="copy-btn" onclick="copyHTML()">Copy HTML</button>
          <button class="btn-secondary" id="copy-table-btn" onclick="copyTableOnly()">Copy table only</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast">Copied to clipboard!</div>

<script>
  const inputEl = document.getElementById('qr-input');
  const ecEl = document.getElementById('ec-level');
  const fgEl = document.getElementById('fg-color');
  const bgEl = document.getElementById('bg-color');
  const fgHex = document.getElementById('fg-hex');
  const bgHex = document.getElementById('bg-hex');
  const cellSizeEl = document.getElementById('cell-size');
  const cellSizeVal = document.getElementById('cell-size-val');
  const quietEl = document.getElementById('quiet-zone');
  const lossyEnabledEl = document.getElementById('lossy-enabled');
  const lossyControlsEl = document.getElementById('lossy-controls');
  const lossyBudgetEl = document.getElementById('lossy-budget');
  const lossyBudgetVal = document.getElementById('lossy-budget-val');
  const lossyStatsEl = document.getElementById('lossy-stats');
  const previewArea = document.getElementById('preview-area');
  const statsEl = document.getElementById('stats');
  const toast = document.getElementById('toast');

  let currentHTML = '';
  let currentTableHTML = '';

  // QR alignment pattern center positions by version
  const ALIGN_POS = [
    null, [], [6,18], [6,22], [6,26], [6,30], [6,34],
    [6,22,38], [6,24,42], [6,26,46], [6,28,50], [6,30,54],
    [6,32,58], [6,34,62], [6,26,46,66], [6,26,48,70], [6,26,50,74],
    [6,30,54,78], [6,30,56,82], [6,30,58,86], [6,34,62,90],
    [6,28,50,72,94], [6,26,50,74,98], [6,30,54,78,102],
    [6,28,54,80,106], [6,32,58,84,110], [6,30,58,86,114],
    [6,34,62,90,118], [6,26,50,74,98,122], [6,30,54,78,102,126],
    [6,26,52,78,104,130], [6,30,56,82,108,134],
    [6,34,60,86,112,138], [6,30,58,86,114,142],
    [6,34,62,90,118,146], [6,30,54,78,102,126,150],
    [6,24,50,76,102,128,154], [6,28,54,80,106,132,158],
    [6,32,58,84,110,136,162], [6,26,54,82,110,138,166],
    [6,30,58,86,114,142,170]
  ];

  // Build protection mask for a given QR moduleCount
  // Returns a 2D array in GRID coordinates (including quiet zone padding)
  function buildProtectionMask(moduleCount, pad, totalSize) {
    const p = Array.from({ length: totalSize }, () => new Uint8Array(totalSize));
    const n = moduleCount;

    // Helper: protect a rect in QR module coords (clamped to grid)
    function protectQR(r0, c0, r1, c1) {
      for (let r = Math.max(0, r0 + pad); r <= Math.min(totalSize - 1, r1 + pad); r++)
        for (let c = Math.max(0, c0 + pad); c <= Math.min(totalSize - 1, c1 + pad); c++)
          p[r][c] = 1;
    }

    // 1. Quiet zone (all padding cells)
    for (let r = 0; r < totalSize; r++)
      for (let c = 0; c < totalSize; c++)
        if (r < pad || r >= totalSize - pad || c < pad || c >= totalSize - pad)
          p[r][c] = 1;

    // 2. Finder patterns (7√ó7) + separator (1 module border around each)
    protectQR(-1, -1, 7, 7);           // top-left finder + separator
    protectQR(-1, n - 8, 7, n);        // top-right finder + separator
    protectQR(n - 8, -1, n, 7);        // bottom-left finder + separator

    // 3. Timing patterns (row 6 and col 6, full length)
    for (let i = 0; i < n; i++) {
      p[6 + pad][i + pad] = 1;
      p[i + pad][6 + pad] = 1;
    }

    // 4. Format information areas
    // Around top-left finder
    for (let i = 0; i <= 8; i++) {
      if (i + pad < totalSize) p[8 + pad][i + pad] = 1;
      if (i + pad < totalSize) p[i + pad][8 + pad] = 1;
    }
    // Right of top-right finder
    for (let i = 0; i < 8; i++) {
      if (n - 1 - i >= 0) p[8 + pad][(n - 1 - i) + pad] = 1;
    }
    // Below bottom-left finder
    for (let i = 0; i < 7; i++) {
      if (n - 1 - i >= 0) p[(n - 1 - i) + pad][8 + pad] = 1;
    }
    // Dark module (always present at version >= 1)
    if (4 * 1 + 9 < n) p[(n - 8) + pad][8 + pad] = 1;

    // 5. Alignment patterns (5√ó5 each)
    const version = Math.ceil((n - 17) / 4);
    if (version >= 2 && version < ALIGN_POS.length) {
      const positions = ALIGN_POS[version];
      for (const ar of positions) {
        for (const ac of positions) {
          // Skip positions that overlap with finder patterns
          if (ar <= 8 && ac <= 8) continue;         // top-left
          if (ar <= 8 && ac >= n - 8) continue;     // top-right
          if (ar >= n - 8 && ac <= 8) continue;     // bottom-left
          protectQR(ar - 2, ac - 2, ar + 2, ac + 2);
        }
      }
    }

    // 6. Version information (versions 7+)
    if (version >= 7) {
      protectQR(0, n - 11, 5, n - 8);   // top-right area
      protectQR(n - 11, 0, n - 8, 5);   // bottom-left area
    }

    return p;
  }

  // Lossy compression: iteratively flip isolated data modules to aid merging.
  // Enhanced with per-flip re-scoring so each flip updates the isolation
  // landscape for its neighbors, producing better cascading improvements.
  function applyLossyCompression(grid, moduleCount, pad, totalSize, ecLevelStr, budget) {
    const protect = buildProtectionMask(moduleCount, pad, totalSize);
    const ecRates = { L: 0.07, M: 0.15, Q: 0.25, H: 0.30 };
    const ecPct = ecRates[ecLevelStr] || 0.07;

    let dataModules = 0;
    for (let r = pad; r < totalSize - pad; r++)
      for (let c = pad; c < totalSize - pad; c++)
        if (!protect[r][c]) dataModules++;

    const maxFlips = Math.floor(dataModules * ecPct * 0.5 * budget);
    if (maxFlips === 0) return 0;

    // Prevent double-flips (flipping a module back wastes budget)
    const wasFlipped = new Uint8Array(totalSize * totalSize);

    // Score a module by isolation from its 8-connected neighborhood.
    // Cardinal diffs drive the threshold; diagonal diffs refine tie-breaking.
    function scoreAt(r, c) {
      if (protect[r][c] || wasFlipped[r * totalSize + c]) return -1;
      const val = grid[r][c];
      let cardDiff = 0;
      if (r > 0 && grid[r - 1][c] !== val) cardDiff++;
      if (r < totalSize - 1 && grid[r + 1][c] !== val) cardDiff++;
      if (c > 0 && grid[r][c - 1] !== val) cardDiff++;
      if (c < totalSize - 1 && grid[r][c + 1] !== val) cardDiff++;
      if (cardDiff < 2) return -1;
      let diagDiff = 0;
      if (r > 0 && c > 0 && grid[r - 1][c - 1] !== val) diagDiff++;
      if (r > 0 && c < totalSize - 1 && grid[r - 1][c + 1] !== val) diagDiff++;
      if (r < totalSize - 1 && c > 0 && grid[r + 1][c - 1] !== val) diagDiff++;
      if (r < totalSize - 1 && c < totalSize - 1 && grid[r + 1][c + 1] !== val) diagDiff++;
      return cardDiff * 10 + diagDiff * 3;
    }

    // Build initial score grid
    const scores = Array.from({ length: totalSize }, () => new Array(totalSize).fill(-1));
    for (let r = pad; r < totalSize - pad; r++)
      for (let c = pad; c < totalSize - pad; c++)
        scores[r][c] = scoreAt(r, c);

    let flippedCount = 0;
    while (flippedCount < maxFlips) {
      // Find the most isolated module
      let bestR = -1, bestC = -1, bestScore = -1;
      for (let r = pad; r < totalSize - pad; r++)
        for (let c = pad; c < totalSize - pad; c++)
          if (scores[r][c] > bestScore) {
            bestScore = scores[r][c];
            bestR = r;
            bestC = c;
          }
      if (bestScore < 0) break;

      // Flip it
      grid[bestR][bestC] = !grid[bestR][bestC];
      wasFlipped[bestR * totalSize + bestC] = 1;
      flippedCount++;

      // Re-score the 3x3 neighborhood affected by the flip
      for (let dr = -1; dr <= 1; dr++)
        for (let dc = -1; dc <= 1; dc++) {
          const nr = bestR + dr, nc = bestC + dc;
          if (nr >= pad && nr < totalSize - pad && nc >= pad && nc < totalSize - pad)
            scores[nr][nc] = scoreAt(nr, nc);
        }
    }

    return flippedCount;
  }

  // Greedy rectangle packing: scan top-left to bottom-right, at each uncovered
  // cell find the maximal-area same-color rectangle anchored there.
  function packGreedy(grid, totalSize) {
    const used = Array.from({ length: totalSize }, () => new Uint8Array(totalSize));

    function findBestRect(r, c) {
      const val = grid[r][c];
      let maxW = 0;
      while (c + maxW < totalSize && grid[r][c + maxW] === val && !used[r][c + maxW]) maxW++;

      let bestArea = 0, bestW = 0, bestH = 0;
      let curW = maxW;

      for (let h = 1; r + h - 1 < totalSize; h++) {
        if (h > 1) {
          const row = r + h - 1;
          let newW = 0;
          while (newW < curW && c + newW < totalSize && grid[row][c + newW] === val && !used[row][c + newW]) newW++;
          curW = newW;
          if (curW === 0) break;
        }
        const area = curW * h;
        if (area > bestArea) { bestArea = area; bestW = curW; bestH = h; }
      }
      return { w: bestW, h: bestH };
    }

    const spans = [];
    for (let r = 0; r < totalSize; r++) spans[r] = new Array(totalSize).fill(null);

    let cellCount = 0;
    for (let r = 0; r < totalSize; r++) {
      for (let c = 0; c < totalSize; c++) {
        if (used[r][c]) continue;
        const { w, h } = findBestRect(r, c);
        spans[r][c] = { w, h, dark: grid[r][c] };
        for (let dr = 0; dr < h; dr++)
          for (let dc = 0; dc < w; dc++)
            used[r + dr][c + dc] = 1;
        cellCount++;
      }
    }

    return { spans, cellCount };
  }

  // Try all 8 orientations of the dihedral group D4 (4 reflections √ó identity/transpose)
  // and return the packing with the fewest cells. Different scan orders cause the greedy
  // algorithm to make different rectangle choices; picking the best eliminates scan-order bias.
  function packBestOrientation(grid, totalSize) {
    const N = totalSize;

    // Identity (original scan order) ‚Äî no grid copy or span transform needed
    let best = packGreedy(grid, N);

    // Remaining 7 orientations: [transpose, flipH, flipV]
    const orientations = [
      [false, true,  false],
      [false, false, true],
      [false, true,  true],
      [true,  false, false],
      [true,  true,  false],
      [true,  false, true],
      [true,  true,  true],
    ];

    for (const [trans, fH, fV] of orientations) {
      // Build the transformed grid
      const tGrid = Array.from({ length: N }, (_, r) => {
        const row = new Array(N);
        for (let c = 0; c < N; c++) {
          let srcR = trans ? c : r;
          let srcC = trans ? r : c;
          if (fV) srcR = N - 1 - srcR;
          if (fH) srcC = N - 1 - srcC;
          row[c] = grid[srcR][srcC];
        }
        return row;
      });

      const result = packGreedy(tGrid, N);
      if (result.cellCount >= best.cellCount) continue;

      // Map spans back to original coordinates
      const newSpans = Array.from({ length: N }, () => new Array(N).fill(null));
      for (let r = 0; r < N; r++)
        for (let c = 0; c < N; c++) {
          const s = result.spans[r][c];
          if (!s) continue;
          // Top-left and bottom-right corners in transformed space
          let tlR = trans ? c : r,              tlC = trans ? r : c;
          let brR = trans ? (c + s.w - 1) : (r + s.h - 1);
          let brC = trans ? (r + s.h - 1) : (c + s.w - 1);
          if (fV) { tlR = N - 1 - tlR; brR = N - 1 - brR; }
          if (fH) { tlC = N - 1 - tlC; brC = N - 1 - brC; }
          const minR = Math.min(tlR, brR), minC = Math.min(tlC, brC);
          const maxR = Math.max(tlR, brR), maxC = Math.max(tlC, brC);
          newSpans[minR][minC] = { w: maxC - minC + 1, h: maxR - minR + 1, dark: s.dark };
        }
      best = { spans: newSpans, cellCount: result.cellCount };
    }

    return best;
  }

  function verifyScan(grid, totalSize) {
    const scale = 10;
    const w = totalSize * scale;
    const h = totalSize * scale;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#000000';
    for (let r = 0; r < totalSize; r++)
      for (let c = 0; c < totalSize; c++)
        if (grid[r][c]) ctx.fillRect(c * scale, r * scale, scale, scale);
    const imageData = ctx.getImageData(0, 0, w, h);
    const result = jsQR(imageData.data, w, h);
    return result ? result.data : null;
  }

  function generate() {
    const text = inputEl.value.trim();
    if (!text) {
      previewArea.innerHTML = '<div class="placeholder-msg"><div class="icon">‚úèÔ∏è</div>Enter text or a URL to generate a QR code</div>';
      statsEl.style.display = 'none';
      return;
    }

    const ecLevel = ecEl.value;
    const fg = fgEl.value;
    const bg = bgEl.value;
    const cellSize = parseInt(cellSizeEl.value);
    const quietZone = quietEl.checked;

    try {
      const qr = qrcode(0, ecLevel);
      qr.addData(text);
      qr.make();

      const moduleCount = qr.getModuleCount();
      const pad = quietZone ? 4 : 0;
      const totalSize = moduleCount + pad * 2;

      // Build a boolean grid (true = dark)
      const grid = [];
      for (let r = 0; r < totalSize; r++) {
        grid[r] = [];
        for (let c = 0; c < totalSize; c++) {
          const qr_r = r - pad, qr_c = c - pad;
          grid[r][c] = (qr_r >= 0 && qr_r < moduleCount && qr_c >= 0 && qr_c < moduleCount) ? qr.isDark(qr_r, qr_c) : false;
        }
      }

      // Shorten hex colors
      function shortHex(hex) {
        if (hex.length === 7 && hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6])
          return '#' + hex[1] + hex[3] + hex[5];
        return hex;
      }
      const fgShort = shortHex(fg);
      const bgShort = shortHex(bg);
      const cs = cellSize;

      // Apply lossy compression if enabled
      let modulesFlipped = 0;
      if (lossyEnabledEl.checked) {
        const budget = parseInt(lossyBudgetEl.value) / 100;
        modulesFlipped = applyLossyCompression(grid, moduleCount, pad, totalSize, ecLevel, budget);
      }

      // Multi-directional rectangle packing (best of 8 D4 orientations)
      const { spans } = packBestOrientation(grid, totalSize);

      let tableHTML = `<table role="presentation" cellpadding="0" cellspacing="0" border="0" style="border-collapse:collapse;border-spacing:0;margin:0 auto;font-size:0;line-height:0;background:${bgShort}">`;
      let cellCount = 0;
      for (let r = 0; r < totalSize; r++) {
        tableHTML += '<tr>';
        for (let c = 0; c < totalSize; c++) {
          const s = spans[r][c];
          if (!s) continue;
          cellCount++;
          let attrs = '';
          if (s.w > 1) attrs += ` colspan="${s.w}"`;
          if (s.h > 1) attrs += ` rowspan="${s.h}"`;
          let style = `width:${cs * s.w}px;height:${cs * s.h}px;padding:0`;
          if (s.dark) style += `;background:${fgShort}`;
          tableHTML += `<td${attrs} style="${style}"></td>`;
        }
        tableHTML += '</tr>';
      }
      tableHTML += '</table>';

      // Wrap for email
      const wrappedHTML = `<!--[if mso]><table role="presentation" cellpadding="0" cellspacing="0" border="0" align="center"><tr><td><![endif]-->\n<div style="text-align:center;padding:16px;">\n${tableHTML}\n</div>\n<!--[if mso]></td></tr></table><![endif]-->`;

      currentTableHTML = tableHTML;
      currentHTML = wrappedHTML;

      // Render preview
      previewArea.innerHTML = `<div class="qr-container" style="background:${bgShort}">${tableHTML}</div>`;

      const totalCells = totalSize * totalSize;
      const htmlSize = (wrappedHTML.length / 1024).toFixed(1);
      const reduction = ((1 - cellCount / totalCells) * 100).toFixed(0);
      statsEl.innerHTML = `<span>${totalSize}√ó${totalSize}</span> grid ¬∑ <span>${cellCount}</span> / ${totalCells} cells (<span>-${reduction}%</span>) ¬∑ <span>${htmlSize} KB</span>`;
      statsEl.style.display = 'block';

      if (lossyEnabledEl.checked && modulesFlipped > 0) {
        const decoded = verifyScan(grid, totalSize);
        if (decoded !== null) {
          lossyStatsEl.innerHTML = `Flipped <span style="color:var(--accent)">${modulesFlipped}</span> modules ¬∑ <span style="color:var(--success)">‚úì Scan verified</span>`;
        } else {
          lossyStatsEl.innerHTML = `Flipped <span style="color:var(--accent)">${modulesFlipped}</span> modules ¬∑ <span style="color:#f44">‚ö† QR may not scan ‚Äî reduce aggressiveness or increase error correction</span>`;
        }
        lossyStatsEl.style.display = 'block';
      } else {
        lossyStatsEl.style.display = 'none';
      }

    } catch (e) {
      previewArea.innerHTML = `<div class="placeholder-msg"><div class="icon">‚ö†Ô∏è</div>Content too long for this error correction level.<br>Try reducing text or lowering error correction.</div>`;
      statsEl.style.display = 'none';
    }
  }

  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
  }

  function copyRich() {
    if (!currentTableHTML) return;
    try {
      const blob = new Blob([currentTableHTML], { type: 'text/html' });
      const item = new ClipboardItem({ 'text/html': blob, 'text/plain': new Blob([currentTableHTML], { type: 'text/plain' }) });
      navigator.clipboard.write([item]).then(() => showToast('Copied! Paste into Gmail ‚úì')).catch(() => showToast('Copy failed'));
    } catch (e) {
      // Fallback: copy as plain HTML
      navigator.clipboard.writeText(currentTableHTML).then(() => showToast('Copied as HTML (rich text not supported in this browser)')).catch(() => showToast('Copy failed'));
    }
  }

  function copyHTML() {
    if (!currentHTML) return;
    navigator.clipboard.writeText(currentHTML).then(() => showToast('Full HTML copied!')).catch(() => showToast('Copy failed'));
  }

  function copyTableOnly() {
    if (!currentTableHTML) return;
    navigator.clipboard.writeText(currentTableHTML).then(() => showToast('Table HTML copied!')).catch(() => showToast('Copy failed'));
  }

  // Event listeners
  fgEl.addEventListener('input', () => { fgHex.textContent = fgEl.value; generate(); });
  bgEl.addEventListener('input', () => { bgHex.textContent = bgEl.value; generate(); });
  cellSizeEl.addEventListener('input', () => { cellSizeVal.textContent = cellSizeEl.value + 'px'; generate(); });

  let debounce;
  inputEl.addEventListener('input', () => { clearTimeout(debounce); debounce = setTimeout(generate, 200); });
  ecEl.addEventListener('change', generate);
  quietEl.addEventListener('change', generate);
  lossyEnabledEl.addEventListener('change', () => {
    lossyControlsEl.style.display = lossyEnabledEl.checked ? 'block' : 'none';
    if (!lossyEnabledEl.checked) lossyStatsEl.style.display = 'none';
    generate();
  });
  lossyBudgetEl.addEventListener('input', () => { lossyBudgetVal.textContent = lossyBudgetEl.value + '%'; generate(); });

  // Initial render
  generate();
</script>

</body>
</html>
